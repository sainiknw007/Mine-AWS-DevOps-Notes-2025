Q.What is Hashicorp vault ?
Q.What are implicit and explicit dependencies ?
Q.Created aws resouces using terraform, 10 resources are there, now want to keep only database and delete all other resources , what are different ways to delete
may---> 
Q. What terraform import Does
Q.if-one-engineer-deleted-tf-state.tx
Q.how-to-delete-resource-from-tf-state.txt
Q. How to create EC2 machine using terraform when it matches ami-id == dsfdssf232, else do not create ?
Q. what are terraform meta arguments ? how to use count , index, depends_on ?
Q. How to delete tfstate file ?
Q. how to get terraform debug logs ? TF_LOG=DEBUG terraform plan > debug.log




What terraform import Does
Brings an existing resource in the real world (AWS, Azure, GCP, etc.) into Terraform state.
Does not create or modify the resource â€” it only tells Terraform â€œthis resource already exists, manage it from now on.â€

Needed if:
Someone created resources manually outside Terraform.
State file was deleted/lost.

Migrating existing infrastructure to Terraform.
ğŸ”¹ Command Syntax
terraform import <resource_address> <resource_id>

<resource_address> â†’ How the resource is defined in your .tf code (e.g., aws_instance.my_ec2).
<resource_id> â†’ The real-world ID of the resource in the cloud (e.g., EC2 ID, S3 bucket name).

ğŸ”¹ Example 1: Import an AWS EC2 Instance
Terraform code:
resource "aws_instance" "my_ec2" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
If an EC2 instance already exists with ID i-0abcd1234ef567890:
terraform import aws_instance.my_ec2 i-0abcd1234ef567890
ğŸ‘‰ Now Terraform state knows that aws_instance.my_ec2 = that existing EC2 instance.
ğŸ”¹ Example 2: Import an S3 Bucket
Terraform code:
resource "aws_s3_bucket" "my_bucket" {
  bucket = "my-example-bucket"
}

If the bucket already exists in AWS:

terraform import aws_s3_bucket.my_bucket my-example-bucket
ğŸ‘‰ The bucket is added to terraform.tfstate.
ğŸ”¹ Example 3: Import with Modules
If the resource is inside a module:
terraform import module.ec2.aws_instance.my_ec2 i-0abcd1234ef567890
ğŸ”¹ Workflow After Import
Write the resource in .tf file.
Run terraform import to map the existing resource into state.
Run terraform plan to check for drift between .tf config and actual infra.
Fix .tf config if needed until Terraform shows no changes.
âœ… Summary
terraform import maps existing infra â†’ Terraform state.
Syntax:
terraform import <resource_address> <resource_id>
Commonly used for recovery or migration.





Answer: Implicit Dependencies and Explicit Dependencies

Terraform manages resource creation order through dependencies, categorized as implicit or explicit.
Implicit Dependencies:
These are automatically inferred by Terraform when one resource's configuration references attributes of another resource.
For example, if a virtual machine resource's network interface configuration references the ID of a previously defined virtual network, Terraform understands that the virtual network must be created before the virtual machine.
Implicit dependencies are generally preferred as they keep the configuration cleaner and allow Terraform to optimize the execution plan more efficiently.
Explicit Dependencies:
These are declared manually using the depends_on meta-argument within a resource block.
Explicit dependencies are used when Terraform cannot automatically infer a dependency, typically when a resource relies on another resource's existence or state, but there's no direct attribute reference in the configuration.
For instance, if an application deployed on a virtual machine requires a specific database to be fully operational before it can start, and there's no direct attribute link between the VM and the database resource in Terraform, an explicit depends_on can be used on the VM resource to ensure the database is created and ready first.
While useful in specific scenarios, overusing depends_on can make the configuration less readable and potentially create unnecessary sequential execution, hindering parallelization.
Summary:
Implicit dependencies: are automatically detected through attribute references, promoting cleaner code and efficient planning.
Explicit dependencies: are manually declared using depends_on for scenarios where automatic inference is not possible, providing control over resource creation order when necessary.
Prioritizing implicit dependencies and using explicit dependencies only when truly required is a best practice for managing Terraform configurations.
